# 设计模式简介

[TOC]

##  1. 目标

+ 理解松耦合设计思想；
+ 掌握面向对象设计原则；
+ 掌握重构技法改善设计；
+ 掌握GOF核心设计模式；

## 2. 什么是设计模式

+ 定义

每一个模式描述了在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

+ 从面向对象谈起
    + 底层思维：向下，如何把握机器底层从微观理解对象构造
        + 语言构造
        + 编译转换
        + 内存模型
        + 运行时机制
    + 抽象思维：向上，如何将我们的周围世界抽象为程序代码；
        + 面向对象
        + 组件封装
        + 设计模式
        + 架构设计
+ 深入理解面向对象
    + 向下：深入理解三大面向对象机制
        + 封装，隐藏内部实现
        + 继承，复用现有代码
        + 多态，改变对象行为
    + 向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”；
+ 软件设计复杂的根本原因
    + 客户需求的变化
    + 技术平台的变化
    + 开发团队的变化
    + 市场环境的变化
    + ...
+ 如何解决复杂性
    + 分解：人们面对复杂性问题有一个常见做法：分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题；
    + 抽象：更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视他的非本质细节，而去处理泛化和理想化了的对象模型；
+ 软件设计的目标
    + 什么是好的软件设计：**复用！**

## 3. 面向对象设计原则

### 3.1 面相对象的优势

抵御变化；

### 3.2 重新认识面向对象

+ 理解隔离变化
    + 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小；

+ 各司其职
    + 从微观层面来看，面相对象的方式更强调各个类的“责任”；
    + 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责；
+ 对象是什么
    + 从语言实现层面来看，对象封装了代码和数据；
    + 从规格层面来讲，对象是一系列可被使用的公共接口；
    + 从概念层面来讲，对象是某种拥有责任的抽象；

### 3.3 面相对象设计原则（重点）

+ 依赖导致原则（DIP）
    + 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）；
    + 抽象（稳定）不应该依赖于）实现细节（变化），实现细节应该依赖于抽象（稳定）；
+ 开放封闭原则（OCP）
    + 对扩展开放，对更改封闭；
    + 类模块应该是可扩展的，但是不可修改；
+ 单一职责原则（SRP)
    + 一个类应该仅有一个引起它变化的原因；
    + 变化的方向隐含着类的责任；
+ Liskov替换原则（LSP)
    + 子类必须能够替换他们的基类；
    + 继承表带类型的抽象；
+ 接口隔离原则（ISP）
    + 不应该强迫客户程序依赖它们不用的方法；
    + 接口应该小而完备；
+ 优先使用对象组合，而不是类继承
    + 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”；
    + 继承在某种程度上破坏了封装性，子类父类耦合度高；
    + 而对象组合则只只要求被组合的对象具有良好的定义的接口，耦合度低；
+ 封装变化点
    + 使用封装来创建对象之间分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合；
+ 针对接口编程，而不是针对实现编程
    + 不将变量类型声明为某个特定的具体类，而是声明为某个接口；
    + 客户程序无需获知对象的具体类型，只需知道对象所具有的接口；
    + 减小系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案；

### 3.4 如何将设计原则提升为设计经验

1. 设计习语 Design Idioms

Design Idioms 描述与特定语言相关的低层模式、技巧、惯用法；

2. 设计模式 Design Patterns

Design Patterns主要描述的是“类与相互通信的对象之间的组织关系，包括他们的角色、职责、协作方式等方面”；

3. 架构模式 Architectural Patterns

Architectural Patterns描述系统中与基本结构组织关系密切的高层模式，包括子系统划分、职责、以及如何组织他们之间关系的规则；